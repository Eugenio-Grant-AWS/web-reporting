{"version":3,"file":"index.umd.min.js","sources":["../src/model/interfaces.ts","../src/model/math.ts","../src/elements/ArcSlice.ts","../src/model/generateArcSlicePath.ts","../src/controllers/patchController.ts","../src/controllers/VennDiagramController.ts","../src/model/layout.ts","../../../../.yarn/berry/cache/@upsetjs-venn.js-npm-2.0.0-535990e54e-10c0.zip/node_modules/@upsetjs/venn.js/build/venn.esm.js","../src/model/euler.ts","../src/controllers/EulerDiagramController.ts","../src/data.ts","../src/index.umd.ts"],"sourcesContent":[null,null,null,null,null,null,null,"const SMALL$1 = 1e-10;\n\n/**\n * Returns the intersection area of a bunch of circles (where each circle\n * is an object having an x,y and radius property)\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @param {undefined | { area?: number, arcArea?: number, polygonArea?: number, arcs?: ReadonlyArray<{ circle: {x: number, y: number, radius: number}, width: number, p1: {x: number, y: number}, p2: {x: number, y: number} }>, innerPoints: ReadonlyArray<{\n    x: number;\n    y: number;\n    parentIndex: [number, number];\n}>, intersectionPoints: ReadonlyArray<{\n  x: number;\n  y: number;\n  parentIndex: [number, number];\n}> }} stats\n * @returns {number}\n */\nfunction intersectionArea(circles, stats) {\n  // get all the intersection points of the circles\n  const intersectionPoints = getIntersectionPoints(circles);\n\n  // filter out points that aren't included in all the circles\n  const innerPoints = intersectionPoints.filter((p) => containedInCircles(p, circles));\n\n  let arcArea = 0;\n  let polygonArea = 0;\n  /** @type {{ circle: {x: number, y: number, radius: number}, width: number, p1: {x: number, y: number}, p2: {x: number, y: number} }[]} */\n  const arcs = [];\n\n  // if we have intersection points that are within all the circles,\n  // then figure out the area contained by them\n  if (innerPoints.length > 1) {\n    // sort the points by angle from the center of the polygon, which lets\n    // us just iterate over points to get the edges\n    const center = getCenter(innerPoints);\n    for (let i = 0; i < innerPoints.length; ++i) {\n      const p = innerPoints[i];\n      p.angle = Math.atan2(p.x - center.x, p.y - center.y);\n    }\n    innerPoints.sort((a, b) => b.angle - a.angle);\n\n    // iterate over all points, get arc between the points\n    // and update the areas\n    let p2 = innerPoints[innerPoints.length - 1];\n    for (let i = 0; i < innerPoints.length; ++i) {\n      const p1 = innerPoints[i];\n\n      // polygon area updates easily ...\n      polygonArea += (p2.x + p1.x) * (p1.y - p2.y);\n\n      // updating the arc area is a little more involved\n      const midPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };\n      /** @types null | { circle: {x: number, y: number, radius: number}, width: number, p1: {x: number, y: number}, p2: {x: number, y: number} } */\n      let arc = null;\n\n      for (let j = 0; j < p1.parentIndex.length; ++j) {\n        if (p2.parentIndex.includes(p1.parentIndex[j])) {\n          // figure out the angle halfway between the two points\n          // on the current circle\n          const circle = circles[p1.parentIndex[j]];\n          const a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y);\n          const a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);\n\n          let angleDiff = a2 - a1;\n          if (angleDiff < 0) {\n            angleDiff += 2 * Math.PI;\n          }\n\n          // and use that angle to figure out the width of the\n          // arc\n          const a = a2 - angleDiff / 2;\n          let width = distance(midPoint, {\n            x: circle.x + circle.radius * Math.sin(a),\n            y: circle.y + circle.radius * Math.cos(a),\n          });\n\n          // clamp the width to the largest is can actually be\n          // (sometimes slightly overflows because of FP errors)\n          if (width > circle.radius * 2) {\n            width = circle.radius * 2;\n          }\n\n          // pick the circle whose arc has the smallest width\n          if (arc == null || arc.width > width) {\n            arc = { circle, width, p1, p2, large: width > circle.radius, sweep: true };\n          }\n        }\n      }\n\n      if (arc != null) {\n        arcs.push(arc);\n        arcArea += circleArea(arc.circle.radius, arc.width);\n        p2 = p1;\n      }\n    }\n  } else {\n    // no intersection points, is either disjoint - or is completely\n    // overlapped. figure out which by examining the smallest circle\n    let smallest = circles[0];\n    for (let i = 1; i < circles.length; ++i) {\n      if (circles[i].radius < smallest.radius) {\n        smallest = circles[i];\n      }\n    }\n\n    // make sure the smallest circle is completely contained in all\n    // the other circles\n    let disjoint = false;\n    for (let i = 0; i < circles.length; ++i) {\n      if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {\n        disjoint = true;\n        break;\n      }\n    }\n\n    if (disjoint) {\n      arcArea = polygonArea = 0;\n    } else {\n      arcArea = smallest.radius * smallest.radius * Math.PI;\n      arcs.push({\n        circle: smallest,\n        p1: { x: smallest.x, y: smallest.y + smallest.radius },\n        p2: { x: smallest.x - SMALL$1, y: smallest.y + smallest.radius },\n        width: smallest.radius * 2,\n        large: true,\n        sweep: true,\n      });\n    }\n  }\n\n  polygonArea /= 2;\n\n  if (stats) {\n    stats.area = arcArea + polygonArea;\n    stats.arcArea = arcArea;\n    stats.polygonArea = polygonArea;\n    stats.arcs = arcs;\n    stats.innerPoints = innerPoints;\n    stats.intersectionPoints = intersectionPoints;\n  }\n\n  return arcArea + polygonArea;\n}\n\n/**\n * returns whether a point is contained by all of a list of circles\n * @param {{x: number, y: number}} point\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @returns {boolean}\n */\nfunction containedInCircles(point, circles) {\n  return circles.every((circle) => distance(point, circle) < circle.radius + SMALL$1);\n}\n\n/**\n * Gets all intersection points between a bunch of circles\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @returns {ReadonlyArray<{x: number, y: number, parentIndex: [number, number]}>}\n */\nfunction getIntersectionPoints(circles) {\n  /** @type {{x: number, y: number, parentIndex: [number, number]}[]} */\n  const ret = [];\n  for (let i = 0; i < circles.length; ++i) {\n    for (let j = i + 1; j < circles.length; ++j) {\n      const intersect = circleCircleIntersection(circles[i], circles[j]);\n      for (const p of intersect) {\n        p.parentIndex = [i, j];\n        ret.push(p);\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n * Circular segment area calculation. See http://mathworld.wolfram.com/CircularSegment.html\n * @param {number} r\n * @param {number} width\n * @returns {number}\n **/\nfunction circleArea(r, width) {\n  return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));\n}\n\n/**\n * euclidean distance between two points\n * @param {{x: number, y: number}} p1\n * @param {{x: number, y: number}} p2\n * @returns {number}\n **/\nfunction distance(p1, p2) {\n  return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\n/**\n * Returns the overlap area of two circles of radius r1 and r2 - that\n * have their centers separated by distance d. Simpler faster\n * circle intersection for only two circles\n * @param {number} r1\n * @param {number} r2\n * @param {number} d\n * @returns {number}\n */\nfunction circleOverlap(r1, r2, d) {\n  // no overlap\n  if (d >= r1 + r2) {\n    return 0;\n  }\n\n  // completely overlapped\n  if (d <= Math.abs(r1 - r2)) {\n    return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);\n  }\n\n  const w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d);\n  const w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);\n  return circleArea(r1, w1) + circleArea(r2, w2);\n}\n\n/**\n * Given two circles (containing a x/y/radius attributes),\n * returns the intersecting points if possible\n * note: doesn't handle cases where there are infinitely many\n * intersection points (circles are equivalent):, or only one intersection point\n * @param {{x: number, y: number, radius: number}} p1\n * @param {{x: number, y: number, radius: number}} p2\n * @returns {ReadonlyArray<{x: number, y: number}>}\n **/\nfunction circleCircleIntersection(p1, p2) {\n  const d = distance(p1, p2);\n  const r1 = p1.radius;\n  const r2 = p2.radius;\n\n  // if to far away, or self contained - can't be done\n  if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) {\n    return [];\n  }\n\n  const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);\n  const h = Math.sqrt(r1 * r1 - a * a);\n  const x0 = p1.x + (a * (p2.x - p1.x)) / d;\n  const y0 = p1.y + (a * (p2.y - p1.y)) / d;\n  const rx = -(p2.y - p1.y) * (h / d);\n  const ry = -(p2.x - p1.x) * (h / d);\n\n  return [\n    { x: x0 + rx, y: y0 - ry },\n    { x: x0 - rx, y: y0 + ry },\n  ];\n}\n\n/**\n * Returns the center of a bunch of points\n * @param {ReadonlyArray<{x: number, y: number}>} points\n * @returns {{x: number, y: number}}\n */\nfunction getCenter(points) {\n  const center = { x: 0, y: 0 };\n  for (const point of points) {\n    center.x += point.x;\n    center.y += point.y;\n  }\n  center.x /= points.length;\n  center.y /= points.length;\n  return center;\n}\n\n/** finds the zeros of a function, given two starting points (which must\n * have opposite signs */\nfunction bisect(f, a, b, parameters) {\n    parameters = parameters || {};\n    const maxIterations = parameters.maxIterations || 100;\n    const tolerance = parameters.tolerance || 1e-10;\n    const fA = f(a);\n    const fB = f(b);\n    let delta = b - a;\n\n    if (fA * fB > 0) {\n        throw 'Initial bisect points must have opposite signs';\n    }\n\n    if (fA === 0) return a;\n    if (fB === 0) return b;\n\n    for (let i = 0; i < maxIterations; ++i) {\n        delta /= 2;\n        const mid = a + delta;\n        const fMid = f(mid);\n\n        if (fMid * fA >= 0) {\n            a = mid;\n        }\n\n        if (Math.abs(delta) < tolerance || fMid === 0) {\n            return mid;\n        }\n    }\n    return a + delta;\n}\n\n// need some basic operations on vectors, rather than adding a dependency,\n// just define here\nfunction zeros(x) {\n    const r = new Array(x);\n    for (let i = 0; i < x; ++i) {\n        r[i] = 0;\n    }\n    return r;\n}\nfunction zerosM(x, y) {\n    return zeros(x).map(() => zeros(y));\n}\n\nfunction dot(a, b) {\n    let ret = 0;\n    for (let i = 0; i < a.length; ++i) {\n        ret += a[i] * b[i];\n    }\n    return ret;\n}\n\nfunction norm2(a) {\n    return Math.sqrt(dot(a, a));\n}\n\nfunction scale(ret, value, c) {\n    for (let i = 0; i < value.length; ++i) {\n        ret[i] = value[i] * c;\n    }\n}\n\nfunction weightedSum(ret, w1, v1, w2, v2) {\n    for (let j = 0; j < ret.length; ++j) {\n        ret[j] = w1 * v1[j] + w2 * v2[j];\n    }\n}\n\n/** minimizes a function using the downhill simplex method */\nfunction nelderMead(f, x0, parameters) {\n    parameters = parameters || {};\n\n    const maxIterations = parameters.maxIterations || x0.length * 200;\n    const nonZeroDelta = parameters.nonZeroDelta || 1.05;\n    const zeroDelta = parameters.zeroDelta || 0.001;\n    const minErrorDelta = parameters.minErrorDelta || 1e-6;\n    const minTolerance = parameters.minErrorDelta || 1e-5;\n    const rho = parameters.rho !== undefined ? parameters.rho : 1;\n    const chi = parameters.chi !== undefined ? parameters.chi : 2;\n    const psi = parameters.psi !== undefined ? parameters.psi : -0.5;\n    const sigma = parameters.sigma !== undefined ? parameters.sigma : 0.5;\n    let maxDiff;\n\n    // initialize simplex.\n    const N = x0.length;\n    const simplex = new Array(N + 1);\n    simplex[0] = x0;\n    simplex[0].fx = f(x0);\n    simplex[0].id = 0;\n    for (let i = 0; i < N; ++i) {\n        const point = x0.slice();\n        point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;\n        simplex[i + 1] = point;\n        simplex[i + 1].fx = f(point);\n        simplex[i + 1].id = i + 1;\n    }\n\n    function updateSimplex(value) {\n        for (let i = 0; i < value.length; i++) {\n            simplex[N][i] = value[i];\n        }\n        simplex[N].fx = value.fx;\n    }\n\n    const sortOrder = (a, b) => a.fx - b.fx;\n\n    const centroid = x0.slice();\n    const reflected = x0.slice();\n    const contracted = x0.slice();\n    const expanded = x0.slice();\n\n    for (let iteration = 0; iteration < maxIterations; ++iteration) {\n        simplex.sort(sortOrder);\n\n        if (parameters.history) {\n            // copy the simplex (since later iterations will mutate) and\n            // sort it to have a consistent order between iterations\n            const sortedSimplex = simplex.map((x) => {\n                const state = x.slice();\n                state.fx = x.fx;\n                state.id = x.id;\n                return state;\n            });\n            sortedSimplex.sort((a, b) => a.id - b.id);\n\n            parameters.history.push({\n                x: simplex[0].slice(),\n                fx: simplex[0].fx,\n                simplex: sortedSimplex,\n            });\n        }\n\n        maxDiff = 0;\n        for (let i = 0; i < N; ++i) {\n            maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));\n        }\n\n        if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta && maxDiff < minTolerance) {\n            break;\n        }\n\n        // compute the centroid of all but the worst point in the simplex\n        for (let i = 0; i < N; ++i) {\n            centroid[i] = 0;\n            for (let j = 0; j < N; ++j) {\n                centroid[i] += simplex[j][i];\n            }\n            centroid[i] /= N;\n        }\n\n        // reflect the worst point past the centroid  and compute loss at reflected\n        // point\n        const worst = simplex[N];\n        weightedSum(reflected, 1 + rho, centroid, -rho, worst);\n        reflected.fx = f(reflected);\n\n        // if the reflected point is the best seen, then possibly expand\n        if (reflected.fx < simplex[0].fx) {\n            weightedSum(expanded, 1 + chi, centroid, -chi, worst);\n            expanded.fx = f(expanded);\n            if (expanded.fx < reflected.fx) {\n                updateSimplex(expanded);\n            } else {\n                updateSimplex(reflected);\n            }\n        }\n\n        // if the reflected point is worse than the second worst, we need to\n        // contract\n        else if (reflected.fx >= simplex[N - 1].fx) {\n            let shouldReduce = false;\n\n            if (reflected.fx > worst.fx) {\n                // do an inside contraction\n                weightedSum(contracted, 1 + psi, centroid, -psi, worst);\n                contracted.fx = f(contracted);\n                if (contracted.fx < worst.fx) {\n                    updateSimplex(contracted);\n                } else {\n                    shouldReduce = true;\n                }\n            } else {\n                // do an outside contraction\n                weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst);\n                contracted.fx = f(contracted);\n                if (contracted.fx < reflected.fx) {\n                    updateSimplex(contracted);\n                } else {\n                    shouldReduce = true;\n                }\n            }\n\n            if (shouldReduce) {\n                // if we don't contract here, we're done\n                if (sigma >= 1) break;\n\n                // do a reduction\n                for (let i = 1; i < simplex.length; ++i) {\n                    weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);\n                    simplex[i].fx = f(simplex[i]);\n                }\n            }\n        } else {\n            updateSimplex(reflected);\n        }\n    }\n\n    simplex.sort(sortOrder);\n    return { fx: simplex[0].fx, x: simplex[0] };\n}\n\n/// searches along line 'pk' for a point that satifies the wolfe conditions\n/// See 'Numerical Optimization' by Nocedal and Wright p59-60\n/// f : objective function\n/// pk : search direction\n/// current: object containing current gradient/loss\n/// next: output: contains next gradient/loss\n/// returns a: step size taken\nfunction wolfeLineSearch(f, pk, current, next, a, c1, c2) {\n    const phi0 = current.fx;\n    const phiPrime0 = dot(current.fxprime, pk);\n    let phi = phi0;\n    let phi_old = phi0;\n    let phiPrime = phiPrime0;\n    let a0 = 0;\n\n    a = a || 1;\n    c1 = c1 || 1e-6;\n    c2 = c2 || 0.1;\n\n    function zoom(a_lo, a_high, phi_lo) {\n        for (let iteration = 0; iteration < 16; ++iteration) {\n            a = (a_lo + a_high) / 2;\n            weightedSum(next.x, 1.0, current.x, a, pk);\n            phi = next.fx = f(next.x, next.fxprime);\n            phiPrime = dot(next.fxprime, pk);\n\n            if (phi > phi0 + c1 * a * phiPrime0 || phi >= phi_lo) {\n                a_high = a;\n            } else {\n                if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n                    return a;\n                }\n\n                if (phiPrime * (a_high - a_lo) >= 0) {\n                    a_high = a_lo;\n                }\n\n                a_lo = a;\n                phi_lo = phi;\n            }\n        }\n\n        return 0;\n    }\n\n    for (let iteration = 0; iteration < 10; ++iteration) {\n        weightedSum(next.x, 1.0, current.x, a, pk);\n        phi = next.fx = f(next.x, next.fxprime);\n        phiPrime = dot(next.fxprime, pk);\n        if (phi > phi0 + c1 * a * phiPrime0 || (iteration && phi >= phi_old)) {\n            return zoom(a0, a, phi_old);\n        }\n\n        if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n            return a;\n        }\n\n        if (phiPrime >= 0) {\n            return zoom(a, a0, phi);\n        }\n\n        phi_old = phi;\n        a0 = a;\n        a *= 2;\n    }\n\n    return a;\n}\n\nfunction conjugateGradient(f, initial, params) {\n    // allocate all memory up front here, keep out of the loop for perfomance\n    // reasons\n    let current = { x: initial.slice(), fx: 0, fxprime: initial.slice() };\n    let next = { x: initial.slice(), fx: 0, fxprime: initial.slice() };\n    const yk = initial.slice();\n    let pk;\n    let temp;\n    let a = 1;\n    let maxIterations;\n\n    params = params || {};\n    maxIterations = params.maxIterations || initial.length * 20;\n\n    current.fx = f(current.x, current.fxprime);\n    pk = current.fxprime.slice();\n    scale(pk, current.fxprime, -1);\n\n    for (let i = 0; i < maxIterations; ++i) {\n        a = wolfeLineSearch(f, pk, current, next, a);\n\n        // todo: history in wrong spot?\n        if (params.history) {\n            params.history.push({\n                x: current.x.slice(),\n                fx: current.fx,\n                fxprime: current.fxprime.slice(),\n                alpha: a,\n            });\n        }\n\n        if (!a) {\n            // faiiled to find point that satifies wolfe conditions.\n            // reset direction for next iteration\n            scale(pk, current.fxprime, -1);\n        } else {\n            // update direction using Polakâ€“Ribiere CG method\n            weightedSum(yk, 1, next.fxprime, -1, current.fxprime);\n\n            const delta_k = dot(current.fxprime, current.fxprime);\n            const beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);\n\n            weightedSum(pk, beta_k, pk, -1, next.fxprime);\n\n            temp = current;\n            current = next;\n            next = temp;\n        }\n\n        if (norm2(current.fxprime) <= 1e-5) {\n            break;\n        }\n    }\n\n    if (params.history) {\n        params.history.push({\n            x: current.x.slice(),\n            fx: current.fx,\n            fxprime: current.fxprime.slice(),\n            alpha: a,\n        });\n    }\n\n    return current;\n}\n\n/**\n * given a list of set objects, and their corresponding overlaps\n * updates the (x, y, radius) attribute on each set such that their positions\n * roughly correspond to the desired overlaps\n * @param {readonly {sets: readonly string[]; size: number; weight?: number}[]} sets\n * @returns {{[setid: string]: {x: number, y: number, radius: number}}}\n */\nfunction venn(sets, parameters = {}) {\n  parameters.maxIterations = parameters.maxIterations || 500;\n\n  const initialLayout = parameters.initialLayout || bestInitialLayout;\n  const loss = parameters.lossFunction || lossFunction;\n\n  // add in missing pairwise areas as having 0 size\n  const areas = addMissingAreas(sets, parameters);\n\n  // initial layout is done greedily\n  const circles = initialLayout(areas, parameters);\n\n  // transform x/y coordinates to a vector to optimize\n  const setids = Object.keys(circles);\n  /** @type {number[]} */\n  const initial = [];\n  for (const setid of setids) {\n    initial.push(circles[setid].x);\n    initial.push(circles[setid].y);\n  }\n\n  // optimize initial layout from our loss function\n  const solution = nelderMead(\n    (values) => {\n      const current = {};\n      for (let i = 0; i < setids.length; ++i) {\n        const setid = setids[i];\n        current[setid] = {\n          x: values[2 * i],\n          y: values[2 * i + 1],\n          radius: circles[setid].radius,\n          // size : circles[setid].size\n        };\n      }\n      return loss(current, areas);\n    },\n    initial,\n    parameters\n  );\n\n  // transform solution vector back to x/y points\n  const positions = solution.x;\n  for (let i = 0; i < setids.length; ++i) {\n    const setid = setids[i];\n    circles[setid].x = positions[2 * i];\n    circles[setid].y = positions[2 * i + 1];\n  }\n\n  return circles;\n}\n\nconst SMALL = 1e-10;\n\n/**\n * Returns the distance necessary for two circles of radius r1 + r2 to\n * have the overlap area 'overlap'\n * @param {number} r1\n * @param {number} r2\n * @param {number} overlap\n * @returns {number}\n */\nfunction distanceFromIntersectArea(r1, r2, overlap) {\n  // handle complete overlapped circles\n  if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + SMALL) {\n    return Math.abs(r1 - r2);\n  }\n\n  return bisect((distance) => circleOverlap(r1, r2, distance) - overlap, 0, r1 + r2);\n}\n\n/**\n * Missing pair-wise intersection area data can cause problems:\n * treating as an unknown means that sets will be laid out overlapping,\n * which isn't what people expect. To reflect that we want disjoint sets\n * here, set the overlap to 0 for all missing pairwise set intersections\n * @param {ReadonlyArray<{sets: ReadonlyArray<string>, size: number}>} areas\n * @returns {ReadonlyArray<{sets: ReadonlyArray<string>, size: number}>}\n */\nfunction addMissingAreas(areas, parameters = {}) {\n  const distinct = parameters.distinct;\n  const r = areas.map((s) => Object.assign({}, s));\n\n  function toKey(arr) {\n    return arr.join(';');\n  }\n\n  if (distinct) {\n    // recreate the full ones by adding things up but just to level two since the rest doesn't matter\n    /** @types Map<string, number> */\n    const count = new Map();\n    for (const area of r) {\n      for (let i = 0; i < area.sets.length; i++) {\n        const si = String(area.sets[i]);\n        count.set(si, area.size + (count.get(si) || 0));\n        for (let j = i + 1; j < area.sets.length; j++) {\n          const sj = String(area.sets[j]);\n          const k1 = `${si};${sj}`;\n          const k2 = `${sj};${si}`;\n          count.set(k1, area.size + (count.get(k1) || 0));\n          count.set(k2, area.size + (count.get(k2) || 0));\n        }\n      }\n    }\n    for (const area of r) {\n      if (area.sets.length < 3) {\n        area.size = count.get(toKey(area.sets));\n      }\n    }\n  }\n\n  // two circle intersections that aren't defined\n  const ids = [];\n\n  /** @type {Set<string>} */\n  const pairs = new Set();\n  for (const area of r) {\n    if (area.sets.length === 1) {\n      ids.push(area.sets[0]);\n    } else if (area.sets.length === 2) {\n      const a = area.sets[0];\n      const b = area.sets[1];\n      pairs.add(toKey(area.sets));\n      pairs.add(toKey([b, a]));\n    }\n  }\n\n  ids.sort((a, b) => (a === b ? 0 : a < b ? -1 : +1));\n\n  for (let i = 0; i < ids.length; ++i) {\n    const a = ids[i];\n    for (let j = i + 1; j < ids.length; ++j) {\n      const b = ids[j];\n      if (!pairs.has(toKey([a, b]))) {\n        r.push({ sets: [a, b], size: 0 });\n      }\n    }\n  }\n  return r;\n}\n\n/**\n * Returns two matrices, one of the euclidean distances between the sets\n * and the other indicating if there are subset or disjoint set relationships\n * @param {ReadonlyArray<{sets: ReadonlyArray<number>}>} areas\n * @param {ReadonlyArray<{size: number}>} sets\n * @param {ReadonlyArray<number>} setids\n */\nfunction getDistanceMatrices(areas, sets, setids) {\n  // initialize an empty distance matrix between all the points\n  /**\n   * @type {number[][]}\n   */\n  const distances = zerosM(sets.length, sets.length);\n  /**\n   * @type {number[][]}\n   */\n  const constraints = zerosM(sets.length, sets.length);\n\n  // compute required distances between all the sets such that\n  // the areas match\n  areas\n    .filter((x) => x.sets.length === 2)\n    .forEach((current) => {\n      const left = setids[current.sets[0]];\n      const right = setids[current.sets[1]];\n      const r1 = Math.sqrt(sets[left].size / Math.PI);\n      const r2 = Math.sqrt(sets[right].size / Math.PI);\n      const distance = distanceFromIntersectArea(r1, r2, current.size);\n\n      distances[left][right] = distances[right][left] = distance;\n\n      // also update constraints to indicate if its a subset or disjoint\n      // relationship\n      let c = 0;\n      if (current.size + 1e-10 >= Math.min(sets[left].size, sets[right].size)) {\n        c = 1;\n      } else if (current.size <= 1e-10) {\n        c = -1;\n      }\n      constraints[left][right] = constraints[right][left] = c;\n    });\n\n  return { distances, constraints };\n}\n\n/// computes the gradient and loss simultaneously for our constrained MDS optimizer\nfunction constrainedMDSGradient(x, fxprime, distances, constraints) {\n  for (let i = 0; i < fxprime.length; ++i) {\n    fxprime[i] = 0;\n  }\n\n  let loss = 0;\n  for (let i = 0; i < distances.length; ++i) {\n    const xi = x[2 * i];\n    const yi = x[2 * i + 1];\n    for (let j = i + 1; j < distances.length; ++j) {\n      const xj = x[2 * j];\n      const yj = x[2 * j + 1];\n      const dij = distances[i][j];\n      const constraint = constraints[i][j];\n\n      const squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi);\n      const distance = Math.sqrt(squaredDistance);\n      const delta = squaredDistance - dij * dij;\n\n      if ((constraint > 0 && distance <= dij) || (constraint < 0 && distance >= dij)) {\n        continue;\n      }\n\n      loss += 2 * delta * delta;\n\n      fxprime[2 * i] += 4 * delta * (xi - xj);\n      fxprime[2 * i + 1] += 4 * delta * (yi - yj);\n\n      fxprime[2 * j] += 4 * delta * (xj - xi);\n      fxprime[2 * j + 1] += 4 * delta * (yj - yi);\n    }\n  }\n  return loss;\n}\n\n/**\n * takes the best working variant of either constrained MDS or greedy\n * @param {ReadonlyArray<{sets: ReadonlyArray<string>, size: number}>} areas\n */\nfunction bestInitialLayout(areas, params = {}) {\n  let initial = greedyLayout(areas, params);\n  const loss = params.lossFunction || lossFunction;\n\n  // greedylayout is sufficient for all 2/3 circle cases. try out\n  // constrained MDS for higher order problems, take its output\n  // if it outperforms. (greedy is aesthetically better on 2/3 circles\n  // since it axis aligns)\n  if (areas.length >= 8) {\n    const constrained = constrainedMDSLayout(areas, params);\n    const constrainedLoss = loss(constrained, areas);\n    const greedyLoss = loss(initial, areas);\n\n    if (constrainedLoss + 1e-8 < greedyLoss) {\n      initial = constrained;\n    }\n  }\n  return initial;\n}\n\n/**\n * use the constrained MDS variant to generate an initial layout\n * @param {ReadonlyArray<{sets: ReadonlyArray<string>, size: number}>} areas\n * @returns {{[key: string]: {x: number, y: number, radius: number}}}\n */\nfunction constrainedMDSLayout(areas, params = {}) {\n  const restarts = params.restarts || 10;\n\n  // bidirectionally map sets to a rowid  (so we can create a matrix)\n  const sets = [];\n  const setids = {};\n  for (const area of areas) {\n    if (area.sets.length === 1) {\n      setids[area.sets[0]] = sets.length;\n      sets.push(area);\n    }\n  }\n\n  let { distances, constraints } = getDistanceMatrices(areas, sets, setids);\n\n  // keep distances bounded, things get messed up otherwise.\n  // TODO: proper preconditioner?\n  const norm = norm2(distances.map(norm2)) / distances.length;\n  distances = distances.map((row) => row.map((value) => value / norm));\n\n  const obj = (x, fxprime) => constrainedMDSGradient(x, fxprime, distances, constraints);\n\n  let best = null;\n  for (let i = 0; i < restarts; ++i) {\n    const initial = zeros(distances.length * 2).map(Math.random);\n\n    const current = conjugateGradient(obj, initial, params);\n    if (!best || current.fx < best.fx) {\n      best = current;\n    }\n  }\n\n  const positions = best.x;\n\n  // translate rows back to (x,y,radius) coordinates\n  /** @type {{[key: string]: {x: number, y: number, radius: number}}} */\n  const circles = {};\n  for (let i = 0; i < sets.length; ++i) {\n    const set = sets[i];\n    circles[set.sets[0]] = {\n      x: positions[2 * i] * norm,\n      y: positions[2 * i + 1] * norm,\n      radius: Math.sqrt(set.size / Math.PI),\n    };\n  }\n\n  if (params.history) {\n    for (const h of params.history) {\n      scale(h.x, norm);\n    }\n  }\n  return circles;\n}\n\n/**\n * Lays out a Venn diagram greedily, going from most overlapped sets to\n * least overlapped, attempting to position each new set such that the\n * overlapping areas to already positioned sets are basically right\n * @param {ReadonlyArray<{size: number, sets: ReadonlyArray<string>}>} areas\n * @return {{[key: string]: {x: number, y: number, radius: number}}}\n */\nfunction greedyLayout(areas, params) {\n  const loss = params && params.lossFunction ? params.lossFunction : lossFunction;\n\n  // define a circle for each set\n  /** @type {{[key: string]: {x: number, y: number, radius: number}}} */\n  const circles = {};\n  /** @type {{[key: string]: {set: string, size: number, weight: number}[]}} */\n  const setOverlaps = {};\n  for (const area of areas) {\n    if (area.sets.length === 1) {\n      const set = area.sets[0];\n      circles[set] = {\n        x: 1e10,\n        y: 1e10,\n        rowid: circles.length,\n        size: area.size,\n        radius: Math.sqrt(area.size / Math.PI),\n      };\n      setOverlaps[set] = [];\n    }\n  }\n\n  areas = areas.filter((a) => a.sets.length === 2);\n\n  // map each set to a list of all the other sets that overlap it\n  for (const current of areas) {\n    let weight = current.weight != null ? current.weight : 1.0;\n    const left = current.sets[0];\n    const right = current.sets[1];\n\n    // completely overlapped circles shouldn't be positioned early here\n    if (current.size + SMALL >= Math.min(circles[left].size, circles[right].size)) {\n      weight = 0;\n    }\n\n    setOverlaps[left].push({ set: right, size: current.size, weight });\n    setOverlaps[right].push({ set: left, size: current.size, weight });\n  }\n\n  // get list of most overlapped sets\n  const mostOverlapped = [];\n  Object.keys(setOverlaps).forEach((set) => {\n    let size = 0;\n    for (let i = 0; i < setOverlaps[set].length; ++i) {\n      size += setOverlaps[set][i].size * setOverlaps[set][i].weight;\n    }\n\n    mostOverlapped.push({ set, size });\n  });\n\n  // sort by size desc\n  function sortOrder(a, b) {\n    return b.size - a.size;\n  }\n  mostOverlapped.sort(sortOrder);\n\n  // keep track of what sets have been laid out\n  const positioned = {};\n  function isPositioned(element) {\n    return element.set in positioned;\n  }\n\n  /**\n   * adds a point to the output\n   * @param {{x: number, y: number}} point\n   * @param {number} index\n   */\n  function positionSet(point, index) {\n    circles[index].x = point.x;\n    circles[index].y = point.y;\n    positioned[index] = true;\n  }\n\n  // add most overlapped set at (0,0)\n  positionSet({ x: 0, y: 0 }, mostOverlapped[0].set);\n\n  // get distances between all points. TODO, necessary?\n  // answer: probably not\n  // var distances = venn.getDistanceMatrices(circles, areas).distances;\n  for (let i = 1; i < mostOverlapped.length; ++i) {\n    const setIndex = mostOverlapped[i].set;\n    const overlap = setOverlaps[setIndex].filter(isPositioned);\n    const set = circles[setIndex];\n    overlap.sort(sortOrder);\n\n    if (overlap.length === 0) {\n      // this shouldn't happen anymore with addMissingAreas\n      throw 'ERROR: missing pairwise overlap information';\n    }\n\n    /** @type {{x: number, y: number}[]} */\n    const points = [];\n    for (var j = 0; j < overlap.length; ++j) {\n      // get appropriate distance from most overlapped already added set\n      const p1 = circles[overlap[j].set];\n      const d1 = distanceFromIntersectArea(set.radius, p1.radius, overlap[j].size);\n\n      // sample positions at 90 degrees for maximum aesthetics\n      points.push({ x: p1.x + d1, y: p1.y });\n      points.push({ x: p1.x - d1, y: p1.y });\n      points.push({ y: p1.y + d1, x: p1.x });\n      points.push({ y: p1.y - d1, x: p1.x });\n\n      // if we have at least 2 overlaps, then figure out where the\n      // set should be positioned analytically and try those too\n      for (let k = j + 1; k < overlap.length; ++k) {\n        const p2 = circles[overlap[k].set];\n        const d2 = distanceFromIntersectArea(set.radius, p2.radius, overlap[k].size);\n\n        const extraPoints = circleCircleIntersection(\n          { x: p1.x, y: p1.y, radius: d1 },\n          { x: p2.x, y: p2.y, radius: d2 }\n        );\n        points.push(...extraPoints);\n      }\n    }\n\n    // we have some candidate positions for the set, examine loss\n    // at each position to figure out where to put it at\n    let bestLoss = 1e50;\n    let bestPoint = points[0];\n    for (const point of points) {\n      circles[setIndex].x = point.x;\n      circles[setIndex].y = point.y;\n      const localLoss = loss(circles, areas);\n      if (localLoss < bestLoss) {\n        bestLoss = localLoss;\n        bestPoint = point;\n      }\n    }\n\n    positionSet(bestPoint, setIndex);\n  }\n\n  return circles;\n}\n\n/**\n * Given a bunch of sets, and the desired overlaps between these sets - computes\n * the distance from the actual overlaps to the desired overlaps. Note that\n * this method ignores overlaps of more than 2 circles\n * @param {{[key: string]: <{x: number, y: number, radius: number}>}} circles\n * @param {ReadonlyArray<{size: number, sets: ReadonlyArray<string>, weight?: number}>} overlaps\n * @returns {number}\n */\nfunction lossFunction(circles, overlaps) {\n  let output = 0;\n\n  for (const area of overlaps) {\n    if (area.sets.length === 1) {\n      continue;\n    }\n    /** @type {number} */\n    let overlap;\n    if (area.sets.length === 2) {\n      const left = circles[area.sets[0]];\n      const right = circles[area.sets[1]];\n      overlap = circleOverlap(left.radius, right.radius, distance(left, right));\n    } else {\n      overlap = intersectionArea(area.sets.map((d) => circles[d]));\n    }\n\n    const weight = area.weight != null ? area.weight : 1.0;\n    output += weight * (overlap - area.size) * (overlap - area.size);\n  }\n\n  return output;\n}\n\nfunction logRatioLossFunction(circles, overlaps) {\n  let output = 0;\n\n  for (const area of overlaps) {\n    if (area.sets.length === 1) {\n      continue;\n    }\n    /** @type {number} */\n    let overlap;\n    if (area.sets.length === 2) {\n      const left = circles[area.sets[0]];\n      const right = circles[area.sets[1]];\n      overlap = circleOverlap(left.radius, right.radius, distance(left, right));\n    } else {\n      overlap = intersectionArea(area.sets.map((d) => circles[d]));\n    }\n\n    const weight = area.weight != null ? area.weight : 1.0;\n    const differenceFromIdeal = Math.log((overlap + 1) / (area.size + 1));\n    output += weight * differenceFromIdeal * differenceFromIdeal;\n  }\n\n  return output;\n}\n\n/**\n * orientates a bunch of circles to point in orientation\n * @param {{x :number, y: number, radius: number}[]} circles\n * @param {number | undefined} orientation\n * @param {((a: {x :number, y: number, radius: number}, b: {x :number, y: number, radius: number}) => number) | undefined} orientationOrder\n */\nfunction orientateCircles(circles, orientation, orientationOrder) {\n  if (orientationOrder == null) {\n    circles.sort((a, b) => b.radius - a.radius);\n  } else {\n    circles.sort(orientationOrder);\n  }\n\n  // shift circles so largest circle is at (0, 0)\n  if (circles.length > 0) {\n    const largestX = circles[0].x;\n    const largestY = circles[0].y;\n\n    for (const circle of circles) {\n      circle.x -= largestX;\n      circle.y -= largestY;\n    }\n  }\n\n  if (circles.length === 2) {\n    // if the second circle is a subset of the first, arrange so that\n    // it is off to one side. hack for https://github.com/benfred/venn.js/issues/120\n    const dist = distance(circles[0], circles[1]);\n    if (dist < Math.abs(circles[1].radius - circles[0].radius)) {\n      circles[1].x = circles[0].x + circles[0].radius - circles[1].radius - 1e-10;\n      circles[1].y = circles[0].y;\n    }\n  }\n\n  // rotate circles so that second largest is at an angle of 'orientation'\n  // from largest\n  if (circles.length > 1) {\n    const rotation = Math.atan2(circles[1].x, circles[1].y) - orientation;\n    const c = Math.cos(rotation);\n    const s = Math.sin(rotation);\n\n    for (const circle of circles) {\n      const x = circle.x;\n      const y = circle.y;\n      circle.x = c * x - s * y;\n      circle.y = s * x + c * y;\n    }\n  }\n\n  // mirror solution if third solution is above plane specified by\n  // first two circles\n  if (circles.length > 2) {\n    let angle = Math.atan2(circles[2].x, circles[2].y) - orientation;\n    while (angle < 0) {\n      angle += 2 * Math.PI;\n    }\n    while (angle > 2 * Math.PI) {\n      angle -= 2 * Math.PI;\n    }\n    if (angle > Math.PI) {\n      const slope = circles[1].y / (1e-10 + circles[1].x);\n      for (const circle of circles) {\n        var d = (circle.x + slope * circle.y) / (1 + slope * slope);\n        circle.x = 2 * d - circle.x;\n        circle.y = 2 * d * slope - circle.y;\n      }\n    }\n  }\n}\n\n/**\n *\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @returns {{x: number, y: number, radius: number}[][]}\n */\nfunction disjointCluster(circles) {\n  // union-find clustering to get disjoint sets\n  circles.forEach((circle) => {\n    circle.parent = circle;\n  });\n\n  // path compression step in union find\n  function find(circle) {\n    if (circle.parent !== circle) {\n      circle.parent = find(circle.parent);\n    }\n    return circle.parent;\n  }\n\n  function union(x, y) {\n    const xRoot = find(x);\n    const yRoot = find(y);\n    xRoot.parent = yRoot;\n  }\n\n  // get the union of all overlapping sets\n  for (let i = 0; i < circles.length; ++i) {\n    for (let j = i + 1; j < circles.length; ++j) {\n      const maxDistance = circles[i].radius + circles[j].radius;\n      if (distance(circles[i], circles[j]) + 1e-10 < maxDistance) {\n        union(circles[j], circles[i]);\n      }\n    }\n  }\n\n  // find all the disjoint clusters and group them together\n  /** @type {Map<string, {x: number, y: number, radius: number}[]>} */\n  const disjointClusters = new Map();\n  for (let i = 0; i < circles.length; ++i) {\n    const setid = find(circles[i]).parent.setid;\n    if (!disjointClusters.has(setid)) {\n      disjointClusters.set(setid, []);\n    }\n    disjointClusters.get(setid).push(circles[i]);\n  }\n\n  // cleanup bookkeeping\n  circles.forEach((circle) => {\n    delete circle.parent;\n  });\n\n  // return in more usable form\n  return Array.from(disjointClusters.values());\n}\n\n/**\n * @param {ReadonlyArray<{x :number, y: number, radius: number}>} circles\n * @returns {{xRange: [number, number], yRange: [number, number]}}\n */\nfunction getBoundingBox(circles) {\n  const minMax = (d) => {\n    const hi = circles.reduce((acc, c) => Math.max(acc, c[d] + c.radius), Number.NEGATIVE_INFINITY);\n    const lo = circles.reduce((acc, c) => Math.min(acc, c[d] - c.radius), Number.POSITIVE_INFINITY);\n    return { max: hi, min: lo };\n  };\n  return { xRange: minMax('x'), yRange: minMax('y') };\n}\n\n/**\n *\n * @param {{[setid: string]: {x: number, y: number, radius: number}}} solution\n * @param {undefined | number} orientation\n * @param {((a: {x :number, y: number, radius: number}, b: {x :number, y: number, radius: number}) => number) | undefined} orientationOrder\n * @returns {{[setid: string]: {x: number, y: number, radius: number}}}\n */\nfunction normalizeSolution(solution, orientation, orientationOrder) {\n  if (orientation == null) {\n    orientation = Math.PI / 2;\n  }\n\n  // work with a list instead of a dictionary, and take a copy so we\n  // don't mutate input\n  let circles = fromObjectNotation(solution).map((d) => Object.assign({}, d));\n\n  // get all the disjoint clusters\n  const clusters = disjointCluster(circles);\n\n  // orientate all disjoint sets, get sizes\n  for (const cluster of clusters) {\n    orientateCircles(cluster, orientation, orientationOrder);\n    const bounds = getBoundingBox(cluster);\n    cluster.size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);\n    cluster.bounds = bounds;\n  }\n  clusters.sort((a, b) => b.size - a.size);\n\n  // orientate the largest at 0,0, and get the bounds\n  circles = clusters[0];\n  let returnBounds = circles.bounds;\n  const spacing = (returnBounds.xRange.max - returnBounds.xRange.min) / 50;\n\n  /**\n   * @param {ReadonlyArray<{x: number, y: number, radius: number, setid: string}>} cluster\n   * @param {boolean} right\n   * @param {boolean} bottom\n   */\n  function addCluster(cluster, right, bottom) {\n    if (!cluster) {\n      return;\n    }\n\n    const bounds = cluster.bounds;\n    /** @type {number} */\n    let xOffset;\n    /** @type {number} */\n    let yOffset;\n\n    if (right) {\n      xOffset = returnBounds.xRange.max - bounds.xRange.min + spacing;\n    } else {\n      xOffset = returnBounds.xRange.max - bounds.xRange.max;\n      const centreing =\n        (bounds.xRange.max - bounds.xRange.min) / 2 - (returnBounds.xRange.max - returnBounds.xRange.min) / 2;\n      if (centreing < 0) {\n        xOffset += centreing;\n      }\n    }\n\n    if (bottom) {\n      yOffset = returnBounds.yRange.max - bounds.yRange.min + spacing;\n    } else {\n      yOffset = returnBounds.yRange.max - bounds.yRange.max;\n      const centreing =\n        (bounds.yRange.max - bounds.yRange.min) / 2 - (returnBounds.yRange.max - returnBounds.yRange.min) / 2;\n      if (centreing < 0) {\n        yOffset += centreing;\n      }\n    }\n\n    for (const c of cluster) {\n      c.x += xOffset;\n      c.y += yOffset;\n      circles.push(c);\n    }\n  }\n\n  let index = 1;\n  while (index < clusters.length) {\n    addCluster(clusters[index], true, false);\n    addCluster(clusters[index + 1], false, true);\n    addCluster(clusters[index + 2], true, true);\n    index += 3;\n\n    // have one cluster (in top left). lay out next three relative\n    // to it in a grid\n    returnBounds = getBoundingBox(circles);\n  }\n\n  // convert back to solution form\n  return toObjectNotation(circles);\n}\n\n/**\n * Scales a solution from venn.venn or venn.greedyLayout such that it fits in\n * a rectangle of width/height - with padding around the borders. also\n * centers the diagram in the available space at the same time.\n * If the scale parameter is not null, this automatic scaling is ignored in favor of this custom one\n * @param {{[setid: string]: {x: number, y: number, radius: number}}} solution\n * @param {number} width\n * @param {number} height\n * @param {number} padding\n * @param {boolean} scaleToFit\n * @returns {{[setid: string]: {x: number, y: number, radius: number}}}\n */\nfunction scaleSolution(solution, width, height, padding, scaleToFit) {\n  const circles = fromObjectNotation(solution);\n\n  width -= 2 * padding;\n  height -= 2 * padding;\n\n  const { xRange, yRange } = getBoundingBox(circles);\n\n  if (xRange.max === xRange.min || yRange.max === yRange.min) {\n    console.log('not scaling solution: zero size detected');\n    return solution;\n  }\n\n  /** @type {number} */\n  let xScaling;\n  /** @type {number} */\n  let yScaling;\n  if (scaleToFit) {\n    const toScaleDiameter = Math.sqrt(scaleToFit / Math.PI) * 2;\n    xScaling = width / toScaleDiameter;\n    yScaling = height / toScaleDiameter;\n  } else {\n    xScaling = width / (xRange.max - xRange.min);\n    yScaling = height / (yRange.max - yRange.min);\n  }\n\n  const scaling = Math.min(yScaling, xScaling);\n  // while we're at it, center the diagram too\n  const xOffset = (width - (xRange.max - xRange.min) * scaling) / 2;\n  const yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;\n\n  return toObjectNotation(\n    circles.map((circle) => ({\n      radius: scaling * circle.radius,\n      x: padding + xOffset + (circle.x - xRange.min) * scaling,\n      y: padding + yOffset + (circle.y - yRange.min) * scaling,\n      setid: circle.setid,\n    }))\n  );\n}\n\n/**\n * @param {readonly {x: number, y: number, radius: number, setid: string}[]} circles\n * @returns {{[setid: string]: {x: number, y: number, radius: number, setid: string}}}\n */\nfunction toObjectNotation(circles) {\n  /** @type {{[setid: string]: {x: number, y: number, radius: number, setid: string}}} */\n  const r = {};\n  for (const circle of circles) {\n    r[circle.setid] = circle;\n  }\n  return r;\n}\n/**\n * @param {{[setid: string]: {x: number, y: number, radius: number}}} solution\n * @returns {{x: number, y: number, radius: number, setid: string}[]}}\n */\nfunction fromObjectNotation(solution) {\n  const setids = Object.keys(solution);\n  return setids.map((id) => Object.assign(solution[id], { setid: id }));\n}\n\n/**\n * VennDiagram includes an optional `options` parameter containing the following option(s):\n *\n * `colourScheme: Array<String>`\n * A list of color values to be applied when coloring diagram circles.\n *\n * `symmetricalTextCentre: Boolean`\n * Whether to symmetrically center each circle's text horizontally and vertically.\n * Defaults to `false`.\n *\n * `textFill: String`\n * The color to be applied to the text within each circle.\n *\n * @param {object} options\n */\nfunction VennDiagram(options = {}) {\n  let useViewBox = false,\n    width = 600,\n    height = 350,\n    padding = 15,\n    duration = 1000,\n    orientation = Math.PI / 2,\n    normalize = true,\n    scaleToFit = null,\n    wrap = true,\n    styled = true,\n    fontSize = null,\n    orientationOrder = null,\n    distinct = false,\n    round = null,\n    symmetricalTextCentre = options && options.symmetricalTextCentre ? options.symmetricalTextCentre : false,\n    // mimic the behaviour of d3.scale.category10 from the previous\n    // version of d3\n    colourMap = {},\n    // so this is the same as d3.schemeCategory10, which is only defined in d3 4.0\n    // since we can support older versions of d3 as long as we don't force this,\n    // I'm hackily redefining below. TODO: remove this and change to d3.schemeCategory10\n    colourScheme =\n      options && options.colourScheme\n        ? options.colourScheme\n        : options && options.colorScheme\n          ? options.colorScheme\n          : [\n              '#1f77b4',\n              '#ff7f0e',\n              '#2ca02c',\n              '#d62728',\n              '#9467bd',\n              '#8c564b',\n              '#e377c2',\n              '#7f7f7f',\n              '#bcbd22',\n              '#17becf',\n            ],\n    colourIndex = 0,\n    colours = function (key) {\n      if (key in colourMap) {\n        return colourMap[key];\n      }\n      var ret = (colourMap[key] = colourScheme[colourIndex]);\n      colourIndex += 1;\n      if (colourIndex >= colourScheme.length) {\n        colourIndex = 0;\n      }\n      return ret;\n    },\n    layoutFunction = venn,\n    loss = lossFunction;\n\n  function chart(selection) {\n    let data = selection.datum();\n\n    // handle 0-sized sets by removing from input\n    const toRemove = new Set();\n    data.forEach((datum) => {\n      if (datum.size == 0 && datum.sets.length == 1) {\n        toRemove.add(datum.sets[0]);\n      }\n    });\n    data = data.filter((datum) => !datum.sets.some((set) => toRemove.has(set)));\n\n    let circles = {};\n    let textCentres = {};\n\n    if (data.length > 0) {\n      let solution = layoutFunction(data, { lossFunction: loss, distinct });\n\n      if (normalize) {\n        solution = normalizeSolution(solution, orientation, orientationOrder);\n      }\n\n      circles = scaleSolution(solution, width, height, padding, scaleToFit);\n      textCentres = computeTextCentres(circles, data, symmetricalTextCentre);\n    }\n\n    // Figure out the current label for each set. These can change\n    // and D3 won't necessarily update (fixes https://github.com/benfred/venn.js/issues/103)\n    const labels = {};\n    data.forEach((datum) => {\n      if (datum.label) {\n        labels[datum.sets] = datum.label;\n      }\n    });\n\n    function label(d) {\n      if (d.sets in labels) {\n        return labels[d.sets];\n      }\n      if (d.sets.length == 1) {\n        return '' + d.sets[0];\n      }\n    }\n\n    // create svg if not already existing\n    selection.selectAll('svg').data([circles]).enter().append('svg');\n\n    const svg = selection.select('svg');\n\n    if (useViewBox) {\n      svg.attr('viewBox', `0 0 ${width} ${height}`);\n    } else {\n      svg.attr('width', width).attr('height', height);\n    }\n\n    // to properly transition intersection areas, we need the\n    // previous circles locations. load from elements\n    const previous = {};\n    let hasPrevious = false;\n    svg.selectAll('.venn-area path').each(function (d) {\n      const path = this.getAttribute('d');\n      if (d.sets.length == 1 && path && !distinct) {\n        hasPrevious = true;\n        previous[d.sets[0]] = circleFromPath(path);\n      }\n    });\n    // interpolate intersection area paths between previous and\n    // current paths\n    function pathTween(d) {\n      return (t) => {\n        const c = d.sets.map((set) => {\n          let start = previous[set];\n          let end = circles[set];\n          if (!start) {\n            start = { x: width / 2, y: height / 2, radius: 1 };\n          }\n          if (!end) {\n            end = { x: width / 2, y: height / 2, radius: 1 };\n          }\n          return {\n            x: start.x * (1 - t) + end.x * t,\n            y: start.y * (1 - t) + end.y * t,\n            radius: start.radius * (1 - t) + end.radius * t,\n          };\n        });\n        return intersectionAreaPath(c, round);\n      };\n    }\n\n    // update data, joining on the set ids\n    const nodes = svg.selectAll('.venn-area').data(data, (d) => d.sets);\n\n    // create new nodes\n    const enter = nodes\n      .enter()\n      .append('g')\n      .attr(\n        'class',\n        (d) =>\n          `venn-area venn-${d.sets.length == 1 ? 'circle' : 'intersection'}${\n            d.colour || d.color ? ' venn-coloured' : ''\n          }`\n      )\n      .attr('data-venn-sets', (d) => d.sets.join('_'));\n\n    const enterPath = enter.append('path');\n    const enterText = enter\n      .append('text')\n      .attr('class', 'label')\n      .text((d) => label(d))\n      .attr('text-anchor', 'middle')\n      .attr('dy', '.35em')\n      .attr('x', width / 2)\n      .attr('y', height / 2);\n\n    // apply minimal style if wanted\n    if (styled) {\n      enterPath\n        .style('fill-opacity', '0')\n        .filter((d) => d.sets.length == 1)\n        .style('fill', (d) => (d.colour ? d.colour : d.color ? d.color : colours(d.sets)))\n        .style('fill-opacity', '.25');\n\n      enterText.style('fill', (d) => {\n        if (d.colour || d.color) {\n          return '#FFF';\n        }\n        if (options.textFill) {\n          return options.textFill;\n        }\n        return d.sets.length == 1 ? colours(d.sets) : '#444';\n      });\n    }\n\n    function asTransition(s) {\n      if (typeof s.transition === 'function') {\n        return s.transition('venn').duration(duration);\n      }\n      return s;\n    }\n\n    // update existing, using pathTween if necessary\n    let update = selection;\n    if (hasPrevious && typeof update.transition === 'function') {\n      update = asTransition(selection);\n      update.selectAll('path').attrTween('d', pathTween);\n    } else {\n      update.selectAll('path').attr('d', (d) => intersectionAreaPath(d.sets.map((set) => circles[set])), round);\n    }\n\n    const updateText = update\n      .selectAll('text')\n      .filter((d) => d.sets in textCentres)\n      .text((d) => label(d))\n      .attr('x', (d) => Math.floor(textCentres[d.sets].x))\n      .attr('y', (d) => Math.floor(textCentres[d.sets].y));\n\n    if (wrap) {\n      if (hasPrevious) {\n        // d3 4.0 uses 'on' for events on transitions,\n        // but d3 3.0 used 'each' instead. switch appropriately\n        if ('on' in updateText) {\n          updateText.on('end', wrapText(circles, label));\n        } else {\n          updateText.each('end', wrapText(circles, label));\n        }\n      } else {\n        updateText.each(wrapText(circles, label));\n      }\n    }\n\n    // remove old\n    const exit = asTransition(nodes.exit()).remove();\n    if (typeof nodes.transition === 'function') {\n      exit.selectAll('path').attrTween('d', pathTween);\n    }\n\n    const exitText = exit\n      .selectAll('text')\n      .attr('x', width / 2)\n      .attr('y', height / 2);\n\n    // if we've been passed a fontSize explicitly, use it to\n    // transition\n    if (fontSize !== null) {\n      enterText.style('font-size', '0px');\n      updateText.style('font-size', fontSize);\n      exitText.style('font-size', '0px');\n    }\n\n    return { circles, textCentres, nodes, enter, update, exit };\n  }\n\n  chart.wrap = function (_) {\n    if (!arguments.length) return wrap;\n    wrap = _;\n    return chart;\n  };\n\n  chart.useViewBox = function () {\n    useViewBox = true;\n    return chart;\n  };\n\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n\n  chart.padding = function (_) {\n    if (!arguments.length) return padding;\n    padding = _;\n    return chart;\n  };\n\n  chart.distinct = function (_) {\n    if (!arguments.length) return distinct;\n    distinct = _;\n    return chart;\n  };\n\n  chart.colours = function (_) {\n    if (!arguments.length) return colours;\n    colours = _;\n    return chart;\n  };\n\n  chart.colors = function (_) {\n    if (!arguments.length) return colours;\n    colours = _;\n    return chart;\n  };\n\n  chart.fontSize = function (_) {\n    if (!arguments.length) return fontSize;\n    fontSize = _;\n    return chart;\n  };\n\n  chart.round = function (_) {\n    if (!arguments.length) return round;\n    round = _;\n    return chart;\n  };\n\n  chart.duration = function (_) {\n    if (!arguments.length) return duration;\n    duration = _;\n    return chart;\n  };\n\n  chart.layoutFunction = function (_) {\n    if (!arguments.length) return layoutFunction;\n    layoutFunction = _;\n    return chart;\n  };\n\n  chart.normalize = function (_) {\n    if (!arguments.length) return normalize;\n    normalize = _;\n    return chart;\n  };\n\n  chart.scaleToFit = function (_) {\n    if (!arguments.length) return scaleToFit;\n    scaleToFit = _;\n    return chart;\n  };\n\n  chart.styled = function (_) {\n    if (!arguments.length) return styled;\n    styled = _;\n    return chart;\n  };\n\n  chart.orientation = function (_) {\n    if (!arguments.length) return orientation;\n    orientation = _;\n    return chart;\n  };\n\n  chart.orientationOrder = function (_) {\n    if (!arguments.length) return orientationOrder;\n    orientationOrder = _;\n    return chart;\n  };\n\n  chart.lossFunction = function (_) {\n    if (!arguments.length) return loss;\n    loss = _ === 'default' ? lossFunction : _ === 'logRatio' ? logRatioLossFunction : _;\n    return chart;\n  };\n\n  return chart;\n}\n\n// sometimes text doesn't fit inside the circle, if thats the case lets wrap\n// the text here such that it fits\n// todo: looks like this might be merged into d3 (\n// https://github.com/mbostock/d3/issues/1642),\n// also worth checking out is\n// http://engineering.findthebest.com/wrapping-axis-labels-in-d3-js/\n// this seems to be one of those things that should be easy but isn't\nfunction wrapText(circles, labeller) {\n  return function (data) {\n    const text = this;\n    const width = circles[data.sets[0]].radius || 50;\n    const label = labeller(data) || '';\n\n    const words = label.split(/\\s+/).reverse();\n    const maxLines = 3;\n    const minChars = (label.length + words.length) / maxLines;\n\n    let word = words.pop();\n    let line = [word];\n    let lineNumber = 0;\n    const lineHeight = 1.1; // ems\n    text.textContent = null; // clear\n    const tspans = [];\n\n    function append(word) {\n      const tspan = text.ownerDocument.createElementNS(text.namespaceURI, 'tspan');\n      tspan.textContent = word;\n      tspans.push(tspan);\n      text.append(tspan);\n      return tspan;\n    }\n    let tspan = append(word);\n\n    while (true) {\n      word = words.pop();\n      if (!word) {\n        break;\n      }\n      line.push(word);\n      const joined = line.join(' ');\n      tspan.textContent = joined;\n      if (joined.length > minChars && tspan.getComputedTextLength() > width) {\n        line.pop();\n        tspan.textContent = line.join(' ');\n        line = [word];\n        tspan = append(word);\n        lineNumber++;\n      }\n    }\n\n    const initial = 0.35 - (lineNumber * lineHeight) / 2;\n    const x = text.getAttribute('x');\n    const y = text.getAttribute('y');\n    tspans.forEach((t, i) => {\n      t.setAttribute('x', x);\n      t.setAttribute('y', y);\n      t.setAttribute('dy', `${initial + i * lineHeight}em`);\n    });\n  };\n}\n\n/**\n *\n * @param {{x: number, y: number}} current\n * @param {ReadonlyArray<{x: number, y: number}>} interior\n * @param {ReadonlyArray<{x: number, y: number}>} exterior\n * @returns {number}\n */\nfunction circleMargin(current, interior, exterior) {\n  let margin = interior[0].radius - distance(interior[0], current);\n\n  for (let i = 1; i < interior.length; ++i) {\n    const m = interior[i].radius - distance(interior[i], current);\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n\n  for (let i = 0; i < exterior.length; ++i) {\n    const m = distance(exterior[i], current) - exterior[i].radius;\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n  return margin;\n}\n\n/**\n * compute the center of some circles by maximizing the margin of\n * the center point relative to the circles (interior) after subtracting\n * nearby circles (exterior)\n * @param {readonly {x: number, y: number, radius: number}[]} interior\n * @param {readonly {x: number, y: number, radius: number}[]} exterior\n * @param {boolean} symmetricalTextCentre\n * @returns {{x:number, y: number}}\n */\nfunction computeTextCentre(interior, exterior, symmetricalTextCentre) {\n  // get an initial estimate by sampling around the interior circles\n  // and taking the point with the biggest margin\n  /** @type {{x: number, y: number}[]} */\n  const points = [];\n  for (const c of interior) {\n    points.push({ x: c.x, y: c.y });\n    points.push({ x: c.x + c.radius / 2, y: c.y });\n    points.push({ x: c.x - c.radius / 2, y: c.y });\n    points.push({ x: c.x, y: c.y + c.radius / 2 });\n    points.push({ x: c.x, y: c.y - c.radius / 2 });\n  }\n\n  let initial = points[0];\n  let margin = circleMargin(points[0], interior, exterior);\n\n  for (let i = 1; i < points.length; ++i) {\n    const m = circleMargin(points[i], interior, exterior);\n    if (m >= margin) {\n      initial = points[i];\n      margin = m;\n    }\n  }\n\n  // maximize the margin numerically\n  const solution = nelderMead(\n    (p) => -1 * circleMargin({ x: p[0], y: p[1] }, interior, exterior),\n    [initial.x, initial.y],\n    { maxIterations: 500, minErrorDelta: 1e-10 }\n  ).x;\n\n  const ret = { x: symmetricalTextCentre ? 0 : solution[0], y: solution[1] };\n\n  // check solution, fallback as needed (happens if fully overlapped\n  // etc)\n  let valid = true;\n  for (const i of interior) {\n    if (distance(ret, i) > i.radius) {\n      valid = false;\n      break;\n    }\n  }\n\n  for (const e of exterior) {\n    if (distance(ret, e) < e.radius) {\n      valid = false;\n      break;\n    }\n  }\n  if (valid) {\n    return ret;\n  }\n\n  if (interior.length == 1) {\n    return { x: interior[0].x, y: interior[0].y };\n  }\n  const areaStats = {};\n  intersectionArea(interior, areaStats);\n\n  if (areaStats.arcs.length === 0) {\n    return { x: 0, y: -1000, disjoint: true };\n  }\n  if (areaStats.arcs.length == 1) {\n    return { x: areaStats.arcs[0].circle.x, y: areaStats.arcs[0].circle.y };\n  }\n  if (exterior.length) {\n    // try again without other circles\n    return computeTextCentre(interior, []);\n  }\n  // take average of all the points in the intersection\n  // polygon. this should basically never happen\n  // and has some issues:\n  // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777\n  return getCenter(areaStats.arcs.map((a) => a.p1));\n}\n\n// given a dictionary of {setid : circle}, returns\n// a dictionary of setid to list of circles that completely overlap it\nfunction getOverlappingCircles(circles) {\n  const ret = {};\n  const circleids = Object.keys(circles);\n  for (const circleid of circleids) {\n    ret[circleid] = [];\n  }\n  for (let i = 0; i < circleids.length; i++) {\n    const ci = circleids[i];\n    const a = circles[ci];\n    for (let j = i + 1; j < circleids.length; ++j) {\n      const cj = circleids[j];\n      const b = circles[cj];\n      const d = distance(a, b);\n\n      if (d + b.radius <= a.radius + 1e-10) {\n        ret[cj].push(ci);\n      } else if (d + a.radius <= b.radius + 1e-10) {\n        ret[ci].push(cj);\n      }\n    }\n  }\n  return ret;\n}\n\nfunction computeTextCentres(circles, areas, symmetricalTextCentre) {\n  const ret = {};\n  const overlapped = getOverlappingCircles(circles);\n  for (let i = 0; i < areas.length; ++i) {\n    const area = areas[i].sets;\n    const areaids = {};\n    const exclude = {};\n\n    for (let j = 0; j < area.length; ++j) {\n      areaids[area[j]] = true;\n      const overlaps = overlapped[area[j]];\n      // keep track of any circles that overlap this area,\n      // and don't consider for purposes of computing the text\n      // centre\n      for (let k = 0; k < overlaps.length; ++k) {\n        exclude[overlaps[k]] = true;\n      }\n    }\n\n    const interior = [];\n    const exterior = [];\n    for (let setid in circles) {\n      if (setid in areaids) {\n        interior.push(circles[setid]);\n      } else if (!(setid in exclude)) {\n        exterior.push(circles[setid]);\n      }\n    }\n    const centre = computeTextCentre(interior, exterior, symmetricalTextCentre);\n    ret[area] = centre;\n    if (centre.disjoint && areas[i].size > 0) {\n      console.log('WARNING: area ' + area + ' not represented on screen');\n    }\n  }\n  return ret;\n}\n\n// sorts all areas in the venn diagram, so that\n// a particular area is on top (relativeTo) - and\n// all other areas are so that the smallest areas are on top\nfunction sortAreas(div, relativeTo) {\n  // figure out sets that are completely overlapped by relativeTo\n  const overlaps = getOverlappingCircles(div.selectAll('svg').datum());\n  const exclude = new Set();\n  for (const check of relativeTo.sets) {\n    for (let setid in overlaps) {\n      const overlap = overlaps[setid];\n      for (let j = 0; j < overlap.length; ++j) {\n        if (overlap[j] == check) {\n          exclude.add(setid);\n          break;\n        }\n      }\n    }\n  }\n\n  // checks that all sets are in exclude;\n  function shouldExclude(sets) {\n    return sets.every((set) => !exclude.has(set));\n  }\n\n  // need to sort div's so that Z order is correct\n  div.selectAll('g').sort((a, b) => {\n    // highest order set intersections first\n    if (a.sets.length != b.sets.length) {\n      return a.sets.length - b.sets.length;\n    }\n\n    if (a == relativeTo) {\n      return shouldExclude(b.sets) ? -1 : 1;\n    }\n    if (b == relativeTo) {\n      return shouldExclude(a.sets) ? 1 : -1;\n    }\n\n    // finally by size\n    return b.size - a.size;\n  });\n}\n\n/**\n * @param {number} x\n * @param {number} y\n * @param {number} r\n * @returns {string}\n */\nfunction circlePath(x, y, r) {\n  const ret = [];\n  ret.push('\\nM', x, y);\n  ret.push('\\nm', -r, 0);\n  ret.push('\\na', r, r, 0, 1, 0, r * 2, 0);\n  ret.push('\\na', r, r, 0, 1, 0, -r * 2, 0);\n  return ret.join(' ');\n}\n\n/**\n * inverse of the circlePath function, returns a circle object from an svg path\n * @param {string} path\n * @returns {{x: number, y: number, radius: number}}\n */\nfunction circleFromPath(path) {\n  const tokens = path.split(' ');\n  return { x: Number.parseFloat(tokens[1]), y: Number.parseFloat(tokens[2]), radius: -Number.parseFloat(tokens[4]) };\n}\n\nfunction intersectionAreaArcs(circles) {\n  if (circles.length === 0) {\n    return [];\n  }\n  const stats = {};\n  intersectionArea(circles, stats);\n  return stats.arcs;\n}\n\nfunction arcsToPath(arcs, round) {\n  if (arcs.length === 0) {\n    return 'M 0 0';\n  }\n  const rFactor = Math.pow(10, round || 0);\n  const r = round != null ? (v) => Math.round(v * rFactor) / rFactor : (v) => v;\n  if (arcs.length == 1) {\n    const circle = arcs[0].circle;\n    return circlePath(r(circle.x), r(circle.y), r(circle.radius));\n  }\n  // draw path around arcs\n  const ret = ['\\nM', r(arcs[0].p2.x), r(arcs[0].p2.y)];\n  for (const arc of arcs) {\n    const radius = r(arc.circle.radius);\n    ret.push('\\nA', radius, radius, 0, arc.large ? 1 : 0, arc.sweep ? 1 : 0, r(arc.p1.x), r(arc.p1.y));\n  }\n  return ret.join(' ');\n}\n\n/**\n * returns a svg path of the intersection area of a bunch of circles\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @returns {string}\n */\nfunction intersectionAreaPath(circles, round) {\n  return arcsToPath(intersectionAreaArcs(circles), round);\n}\n\nfunction layout(data, options = {}) {\n  const {\n    lossFunction: loss,\n    layoutFunction: layout = venn,\n    normalize = true,\n    orientation = Math.PI / 2,\n    orientationOrder,\n    width = 600,\n    height = 350,\n    padding = 15,\n    scaleToFit = false,\n    symmetricalTextCentre = false,\n    distinct,\n    round = 2,\n  } = options;\n\n  let solution = layout(data, {\n    lossFunction: loss === 'default' || !loss ? lossFunction : loss === 'logRatio' ? logRatioLossFunction : loss,\n    distinct,\n  });\n\n  if (normalize) {\n    solution = normalizeSolution(solution, orientation, orientationOrder);\n  }\n\n  const circles = scaleSolution(solution, width, height, padding, scaleToFit);\n  const textCentres = computeTextCentres(circles, data, symmetricalTextCentre);\n\n  const circleLookup = new Map(\n    Object.keys(circles).map((set) => [\n      set,\n      {\n        set,\n        x: circles[set].x,\n        y: circles[set].y,\n        radius: circles[set].radius,\n      },\n    ])\n  );\n  const helpers = data.map((area) => {\n    const circles = area.sets.map((s) => circleLookup.get(s));\n    const arcs = intersectionAreaArcs(circles);\n    const path = arcsToPath(arcs, round);\n    return { circles, arcs, path, area, has: new Set(area.sets) };\n  });\n\n  function genDistinctPath(sets) {\n    let r = '';\n    for (const e of helpers) {\n      if (e.has.size > sets.length && sets.every((s) => e.has.has(s))) {\n        r += ' ' + e.path;\n      }\n    }\n    return r;\n  }\n\n  return helpers.map(({ circles, arcs, path, area }) => {\n    return {\n      data: area,\n      text: textCentres[area.sets],\n      circles,\n      arcs,\n      path,\n      distinctPath: path + genDistinctPath(area.sets),\n    };\n  });\n}\n\nexport { VennDiagram, bestInitialLayout, circleArea, circleCircleIntersection, circleFromPath, circleOverlap, circlePath, computeTextCentre, computeTextCentres, disjointCluster, distance, distanceFromIntersectArea, greedyLayout, intersectionArea, intersectionAreaPath, layout, logRatioLossFunction, lossFunction, normalizeSolution, scaleSolution, sortAreas, venn, wrapText };\n",null,null,null,null],"names":["isEllipse","d","rx","dist","a","b","x","cx","y","cy","Math","sqrt","DEG2RAD","PI","pointAtCircle","radius","angle","cos","sin","ArcSlice","Element","inRange","mouseX","mouseY","props","this","getProps","usedSets","Set","sets","checkRef","p","ref","inside","rotation","ry","r","arc","_a","arcs","refs","Number","isNaN","delete","mode","remaining","Array","from","i","length","inXRange","NaN","inYRange","getCenterPoint","text","tooltipPosition","hasValue","draw","ctx","save","options","path","beginPath","window","Path2D","s","x1","y1","map","rot","large","sweep","x2","y2","join","generateArcSlicePath","moveTo","ellipse","closePath","backgroundColor","fillStyle","fill","borderColor","strokeStyle","lineWidth","borderWidth","stroke","restore","id","defaults","BarElement","defaultRoutes","patchController","type","config","controller","elements","scales","registry","addControllers","isArray","addElements","addScales","c","VennDiagramController","DatasetController","initialize","super","enableOptionSharing","update","slices","_cachedMeta","data","updateElements","computeLayout","size","bb","lookup","venn0","venn1","venn2","venn3","venn4","venn5","min","f","width","height","mx","v","my","intersections","layout","log2","start","count","xScale","yScale","w","right","left","h","bottom","top","l","_layout","_setLayoutFont","_resolveTickFontOptions","color","ticks","_labelLayoutFont","firstOpts","resolveDataElementOptions","sharedOptions","getSharedOptions","includeOptions","slice","properties","updateElement","updateSharedOptions","chart","forEach","elem","drawLabels","meta","setLayoutScale","setLayoutFont","labelLayoutScale","labelLayoutFont","display","font","string","textBaseline","labels","set","textAlign","align","verticalAlign","fillText","values","getDataset","intersection","value","toLocaleString","dataElementType","overrides","plugins","tooltip","callbacks","title","label","item","_b","datasets","datasetIndex","dataIndex","max","VennDiagramChart","Chart","constructor","LinearScale","SMALL$1","intersectionArea","circles","stats","intersectionPoints","ret","j","intersect","circleCircleIntersection","parentIndex","push","getIntersectionPoints","innerPoints","filter","point","every","circle","distance","containedInCircles","arcArea","polygonArea","center","getCenter","atan2","sort","p2","p1","midPoint","includes","a1","a2","angleDiff","circleArea","smallest","disjoint","abs","area","acos","circleOverlap","r1","r2","w2","x0","y0","points","zeros","zerosM","dot","norm2","scale","weightedSum","w1","v1","v2","nelderMead","parameters","maxIterations","nonZeroDelta","zeroDelta","minErrorDelta","minTolerance","rho","undefined","chi","psi","sigma","maxDiff","N","simplex","fx","updateSimplex","sortOrder","centroid","reflected","contracted","expanded","iteration","history","sortedSimplex","state","worst","shouldReduce","wolfeLineSearch","pk","current","next","c1","c2","phi0","phiPrime0","fxprime","phi","phi_old","phiPrime","a0","zoom","a_lo","a_high","phi_lo","conjugateGradient","initial","params","yk","temp","alpha","delta_k","venn","initialLayout","bestInitialLayout","loss","lossFunction","areas","distinct","Object","assign","toKey","arr","Map","si","String","get","sj","k1","k2","ids","pairs","add","has","addMissingAreas","setids","keys","setid","positions","SMALL","distanceFromIntersectArea","overlap","tolerance","fA","fB","delta","mid","fMid","bisect","setOverlaps","rowid","weight","mostOverlapped","positioned","isPositioned","element","positionSet","index","setIndex","d1","k","d2","extraPoints","bestLoss","bestPoint","localLoss","greedyLayout","constrained","restarts","distances","constraints","getDistanceMatrices","norm","row","obj","xi","yi","xj","yj","dij","constraint","squaredDistance","constrainedMDSGradient","best","random","constrainedMDSLayout","overlaps","output","logRatioLossFunction","differenceFromIdeal","log","orientateCircles","orientation","orientationOrder","largestX","largestY","slope","getBoundingBox","minMax","reduce","acc","NEGATIVE_INFINITY","POSITIVE_INFINITY","xRange","yRange","normalizeSolution","solution","fromObjectNotation","clusters","find","parent","union","xRoot","yRoot","maxDistance","disjointClusters","disjointCluster","cluster","bounds","returnBounds","spacing","addCluster","xOffset","yOffset","centreing","toObjectNotation","circleMargin","interior","exterior","margin","m","computeTextCentre","symmetricalTextCentre","valid","e","areaStats","computeTextCentres","overlapped","circleids","circleid","ci","cj","getOverlappingCircles","areaids","exclude","centre","console","layoutFunction","normalize","padding","scaleToFit","round","xScaling","yScaling","toScaleDiameter","scaling","scaleSolution","textCentres","circleLookup","helpers","intersectionAreaArcs","rFactor","pow","circlePath","arcsToPath","genDistinctPath","distinctPath","shiftPath","mapX","parseFloat","toString","mapY","split","line","parts","trim","euler","singleSets","setNames","setCircles","eulerCenter","sumX","sumY","setData","angleAtCircle","asArc","findIndex","subSets","subSet","indexOf","EulerDiagramController","_data","EulerDiagramChart","generateSubset","members","notMembers","others","not","o","degree","base"],"mappings":"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","x_google_ignoreList":[7]}